<!DOCTYPE html>
<html itemscope itemtype="http://schema.org/WebPage" lang="en-us">
  <head><script src="/d1ff/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=d1ff/livereload" data-no-instant defer></script>
    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
    <meta name="robots" content="noodp" />
    <title>Squ1rrelCTF 2025 Writeup (Pwn/Squ1rrel_logon) - d1ff</title><meta name="author" content="_d1ff">
<meta name="description" content="Over the weekend, I teamed up with my friends to play SquirrelCTF.
The event was amazing, and the pwn challenges in particular really stood out — they forced us to think hard, connect clues, and improve our skills.
hereby I will be delivering a detailed writeup of the logon challenge.
Before diving deeper, let’s take a quick moment to understand the concept of Threading.
CONCURRENT PROGRAMMINGAs the name suggests, concurrent programming is all about doing multiple things at once. &ldquo;Concurrent&rdquo; means happening simultaneously, and &ldquo;programming&rdquo;—well, you already know that part 😉.
Concurrent programming allows a program to perform several tasks simultaneously instead of having to wait for the result of one operation to move onto the next.
There are three ways to implement concurrency in our programs: processes, threads, and multiplexing. Let’s concentrate on threads.
THREADINGAn execution thread is a logical sequence of instructions inside a process that is automatically managed by the operating system’s kernel. A regular sequential program has a single thread, but modern operating systems allow us to create several threads in our programs, all of which run in parallel.
Each one of a process’s threads has its own context: its own thread ID, its own stack, its own instruction pointer, it’s own processor register .
BUT since all of the thread are part of the same process, they share the same VIRTUAL MEMORY ADDRESS SPACE : the same code, the same heap, the same shared libraries and the same open file descriptors.
As shown in the image, threads from the same process share the code, data, and files, but each one gets its own stack to work with.
Let’s look at a simple c program that uses threading.1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include &lt;stdio.h&gt; #include &lt;pthread.h&gt; // This is the function that the thread will run void* myThreadFunction(void* arg) { printf(&#34;Hello from the thread!\n&#34;); return NULL; } int main() { pthread_t thread; // Create a new thread that runs myThreadFunction if (pthread_create(&amp;thread, NULL, myThreadFunction, NULL) != 0) { perror(&#34;Failed to create thread&#34;); return 1; } // Wait for the thread to finish if (pthread_join(thread, NULL) != 0) { perror(&#34;Failed to join thread&#34;); return 1; } printf(&#34;Thread has finished execution.\n&#34;); return 0; } To compile and run the program—&gt; gcc -o simple_thread simple_thread.c -pthread
`./simple_thread`Lets look at some of the useful syntax here :-
pthread_tThis is just a data type (basically like an int or a struct) that is used to store the ID of a thread. When you create a thread, you need a pthread_t variable to hold a reference to that thread so you can interact with it later (e.g., wait for it to finish). pthread_createThis creates a new thread. It starts running a function you specify — in parallel with your main() function. 1 int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg); pthread_joinThis waits for a thread to finish. It blocks (pauses) your main() program until the specified thread is done running. 1 int pthread_join(pthread_t thread, void **retval); A visual map of the program above
1 2 3 4 5 6 main() starts | |--&gt; pthread_create --&gt; myThreadFunction() runs in parallel | |--&gt; pthread_join --&gt; wait until myThreadFunction() is done main() continues after join here is the virtual memory map of the above process.Before pthread_create is being called
After pthread_create is being called
Now since we have learnt all the requisites to understand the source code of the pwn_logon binary.
lets first have a look of the decompiled binary.
This is the main fucntion.
First, it disables buffering on stdout and stdin using setbuf (this can be ignored for now).
Then it prints a banner by calling the print_banner function (also not important here).
After that:
At line 6, it creates a thread that runs the userinfo function. At line 7, it creates another thread that runs the auth function. Finally, it waits for the auth_thread to finish execution using pthread_join, and then the program exits.
ALL good HERE
This is the userinfo function.
lets see!!
The userinfo function first asks the user for the length of their first name and surname.
It then uses alloca to allocate memory after paddig the size with blocks of 16 bytes , for both names on the stack, based on the provided lengths, and reads in the names using readline.
At first glance, this looks simple.
But there’s a lurking vulnerability:
alloca is a C built-in function that allocates memory dynamically on the stack, not on the heap.
In a thread (like here), the stack size is fixed when the thread is created. It’s usually around 0x8000 bytes (or 0x10000 bytes), depending on system and settings.
Since the function explicitly asks the user for the name and surname sizes, and only enforces that length &lt; 0x100000000 (i.e., under 4GB, which is huge), the user can request very large allocations.
If the combined size of allocations exceeds the thread’s stack limit, this can lead to a stack overflow inside the thread.
🧠 keep this vuln in mind it may be useful later for exploitation.
This is auth function.
Here&rsquo;s where the real objective becomes clear:
The auth function:
Opens the file flag.txt and reads its contents into a stack buffer (inside the auth thread’s stack). Then it waits for the userinfo_thread to complete by calling pthread_join. After that, it prompts the user to enter a security token. The program then compares the user input against the contents read from flag.txt.
If the strings match, it calls system(&quot;/bin/sh&quot;) and gives shell access. Otherwise, it prints an ACCESS DENIED message and terminates. Now since we have understood what the program is doing let’s take a look on virtual memory mapping of it with the help of gdb-pwndbg .
As we observed in the main function, the auth_thread is created after the userinfo_thread.
By default, new thread stacks are allocated at lower memory addresses than those of previously created threads.
Looking at the memory layout here, we notice:
There is a guard page (0x1000 bytes = 1 page) between the two thread stacks, protecting them from each other. However, between the end of auth_thread&rsquo;s stack and the second guard page, there is a large gap of 0x1ff000 bytes locally. 💡Interestingly, when running on the remote instance, I observed that this gap was absent — meaning the guard pages and thread stacks are fully contiguous on the remote server.
The decompilation is performed using ida8.9
🤔 EXPLOITATION ROUTETime to activate the hippocampus and connect the dots. 🧠
We know there’s a potential stack overflow in the userinfo thread, and that the auth function runs in parallel (more precisely, concurrently).
If we look carefully:
In auth, the contents of flag.txt are read into a stack buffer early on. After reading, auth calls pthread_join to wait for userinfo_thread to finish. Important: At the time we are writing our name and surname in userinfo, the buffer inside auth is already populated. This opens an opportunity:
If we can leak or overwrite the auth thread’s buffer, we can control the value used in the strcmp check. If we can make the comparison pass, we can trigger system(&quot;/bin/sh&quot;) and get a shell. Now, recall another crucial observation:
The stack regions for userinfo_thread and auth_thread are aligned and adjacent (next to each other) in memory. Thus, if we:
Allocate a large enough name or surname buffer inside userinfo (using alloca), The allocation can spill over into the auth_thread&rsquo;s stack region, especially the part where the flag.txt buffer is stored. Using gdb-pwndbg, I determined that the offset between the base address of the name_buffer (allocated in userinfo_thread) and the auth thread’s buffer is approximately 8,392,928 bytes — assuming the memory between the two thread stacks is contiguous.
💡Another cool property of strcmpis that it compares two strings character-by-character until it encounters a null byte (\0). In C, strings are null-terminated, so strcmp effectively stops checking as soon as it hits the first null byte.
This means if we manage to overwrite the beginning of the flag buffer with null bytes , and simultaneously provide an input consisting of only null bytes, strcmp will treat them as matching — allowing us to bypass the security check.
Here is the Exploitation Script1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #!/usr/bin/env python3 from pwn import * elf = ELF(&#34;./terminal_patched&#34;) libc = ELF(&#34;./libc.so.6&#34;) ld = ELF(&#34;./ld-linux-x86-64.so.2&#34;) context.binary = elf r = remote(&#39;20.84.72.194&#39;, &#39;5005&#39;) # r = process() # gdb.attach(r,gdbscript=&#39;b userinfo&#39;) r.sendlineafter(b&#39;First Name Length: &#39;,f&#39;{8392928-23}&#39;) #-23 because the program is adding 23 r.sendlineafter(b&#39;Surname Length: &#39;,str(0x400-23).encode()) r.sendlineafter(b&#39;First Name:&#39;,b&#39;\x00&#39;*0x20&#43;b&#39;\n&#39;) ##### filling the name/flag buffer with null r.sendlineafter(b&#39;Surname:&#39;,b&#39;\x00&#39;*0x10&#43;b&#39;\n&#39;) r.sendlineafter(b&#39;Enter security token:&#39;,b&#39;\x00&#39;*100&#43;b&#39;\n&#39;) r.interactive() 🐿️ SummaryHere&rsquo;s a quick summary for time-pressed readers
The core idea was about multithreading: two threads, userinfo and auth, running side by side.
userinfo asked for your name and allocated memory on the stack using alloca. auth read the flag into its own stack buffer and waited for userinfo to finish. On remote, the thread stacks were contiguous — only a tiny guard page separating them.
Using alloca, we could allocate a massive buffer in userinfo and overflow into auth&rsquo;s stack, right where the flag was stored!
we could overwrite the start of the flag buffer with null bytes. Since strcmp stops at the first null, it would treat our null-filled input as matching — and trigger a shell.
Useful linkshttps://www.scaler.com/topics/multithreading-in-c/
https://www.codequoi.com/en/threads-mutexes-and-concurrent-programming-in-c/
🔗 Connect with me:GitHub twitter "><meta name="keywords" content='Threads, Processes'>
  <meta itemprop="name" content="Squ1rrelCTF 2025 writeup (pwn/Squ1rrel_logon)">
  <meta itemprop="description" content="Over the weekend, I teamed up with my friends to play SquirrelCTF.
The event was amazing, and the pwn challenges in particular really stood out — they forced us to think hard, connect clues, and improve our skills.
hereby I will be delivering a detailed writeup of the logon challenge.
Before diving deeper, let’s take a quick moment to understand the concept of Threading.
CONCURRENT PROGRAMMINGAs the name suggests, concurrent programming is all about doing multiple things at once. “Concurrent” means happening simultaneously, and “programming”—well, you already know that part 😉.
Concurrent programming allows a program to perform several tasks simultaneously instead of having to wait for the result of one operation to move onto the next.
There are three ways to implement concurrency in our programs: processes, threads, and multiplexing. Let’s concentrate on threads.
THREADINGAn execution thread is a logical sequence of instructions inside a process that is automatically managed by the operating system’s kernel. A regular sequential program has a single thread, but modern operating systems allow us to create several threads in our programs, all of which run in parallel.
Each one of a process’s threads has its own context: its own thread ID, its own stack, its own instruction pointer, it’s own processor register .
BUT since all of the thread are part of the same process, they share the same VIRTUAL MEMORY ADDRESS SPACE : the same code, the same heap, the same shared libraries and the same open file descriptors.
As shown in the image, threads from the same process share the code, data, and files, but each one gets its own stack to work with.
Let’s look at a simple c program that uses threading.1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include &lt;stdio.h&gt; #include &lt;pthread.h&gt; // This is the function that the thread will run void* myThreadFunction(void* arg) { printf(&#34;Hello from the thread!\n&#34;); return NULL; } int main() { pthread_t thread; // Create a new thread that runs myThreadFunction if (pthread_create(&amp;thread, NULL, myThreadFunction, NULL) != 0) { perror(&#34;Failed to create thread&#34;); return 1; } // Wait for the thread to finish if (pthread_join(thread, NULL) != 0) { perror(&#34;Failed to join thread&#34;); return 1; } printf(&#34;Thread has finished execution.\n&#34;); return 0; } To compile and run the program—&gt; gcc -o simple_thread simple_thread.c -pthread
`./simple_thread`Lets look at some of the useful syntax here :-
pthread_tThis is just a data type (basically like an int or a struct) that is used to store the ID of a thread. When you create a thread, you need a pthread_t variable to hold a reference to that thread so you can interact with it later (e.g., wait for it to finish). pthread_createThis creates a new thread. It starts running a function you specify — in parallel with your main() function. 1 int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg); pthread_joinThis waits for a thread to finish. It blocks (pauses) your main() program until the specified thread is done running. 1 int pthread_join(pthread_t thread, void **retval); A visual map of the program above
1 2 3 4 5 6 main() starts | |--&gt; pthread_create --&gt; myThreadFunction() runs in parallel | |--&gt; pthread_join --&gt; wait until myThreadFunction() is done main() continues after join here is the virtual memory map of the above process.Before pthread_create is being called
After pthread_create is being called
Now since we have learnt all the requisites to understand the source code of the pwn_logon binary.
lets first have a look of the decompiled binary.
This is the main fucntion.
First, it disables buffering on stdout and stdin using setbuf (this can be ignored for now).
Then it prints a banner by calling the print_banner function (also not important here).
After that:
At line 6, it creates a thread that runs the userinfo function. At line 7, it creates another thread that runs the auth function. Finally, it waits for the auth_thread to finish execution using pthread_join, and then the program exits.
ALL good HERE
This is the userinfo function.
lets see!!
The userinfo function first asks the user for the length of their first name and surname.
It then uses alloca to allocate memory after paddig the size with blocks of 16 bytes , for both names on the stack, based on the provided lengths, and reads in the names using readline.
At first glance, this looks simple.
But there’s a lurking vulnerability:
alloca is a C built-in function that allocates memory dynamically on the stack, not on the heap.
In a thread (like here), the stack size is fixed when the thread is created. It’s usually around 0x8000 bytes (or 0x10000 bytes), depending on system and settings.
Since the function explicitly asks the user for the name and surname sizes, and only enforces that length &lt; 0x100000000 (i.e., under 4GB, which is huge), the user can request very large allocations.
If the combined size of allocations exceeds the thread’s stack limit, this can lead to a stack overflow inside the thread.
🧠 keep this vuln in mind it may be useful later for exploitation.
This is auth function.
Here’s where the real objective becomes clear:
The auth function:
Opens the file flag.txt and reads its contents into a stack buffer (inside the auth thread’s stack). Then it waits for the userinfo_thread to complete by calling pthread_join. After that, it prompts the user to enter a security token. The program then compares the user input against the contents read from flag.txt.
If the strings match, it calls system(&#34;/bin/sh&#34;) and gives shell access. Otherwise, it prints an ACCESS DENIED message and terminates. Now since we have understood what the program is doing let’s take a look on virtual memory mapping of it with the help of gdb-pwndbg .
As we observed in the main function, the auth_thread is created after the userinfo_thread.
By default, new thread stacks are allocated at lower memory addresses than those of previously created threads.
Looking at the memory layout here, we notice:
There is a guard page (0x1000 bytes = 1 page) between the two thread stacks, protecting them from each other. However, between the end of auth_thread’s stack and the second guard page, there is a large gap of 0x1ff000 bytes locally. 💡Interestingly, when running on the remote instance, I observed that this gap was absent — meaning the guard pages and thread stacks are fully contiguous on the remote server.
The decompilation is performed using ida8.9
🤔 EXPLOITATION ROUTETime to activate the hippocampus and connect the dots. 🧠
We know there’s a potential stack overflow in the userinfo thread, and that the auth function runs in parallel (more precisely, concurrently).
If we look carefully:
In auth, the contents of flag.txt are read into a stack buffer early on. After reading, auth calls pthread_join to wait for userinfo_thread to finish. Important: At the time we are writing our name and surname in userinfo, the buffer inside auth is already populated. This opens an opportunity:
If we can leak or overwrite the auth thread’s buffer, we can control the value used in the strcmp check. If we can make the comparison pass, we can trigger system(&#34;/bin/sh&#34;) and get a shell. Now, recall another crucial observation:
The stack regions for userinfo_thread and auth_thread are aligned and adjacent (next to each other) in memory. Thus, if we:
Allocate a large enough name or surname buffer inside userinfo (using alloca), The allocation can spill over into the auth_thread’s stack region, especially the part where the flag.txt buffer is stored. Using gdb-pwndbg, I determined that the offset between the base address of the name_buffer (allocated in userinfo_thread) and the auth thread’s buffer is approximately 8,392,928 bytes — assuming the memory between the two thread stacks is contiguous.
💡Another cool property of strcmpis that it compares two strings character-by-character until it encounters a null byte (\0). In C, strings are null-terminated, so strcmp effectively stops checking as soon as it hits the first null byte.
This means if we manage to overwrite the beginning of the flag buffer with null bytes , and simultaneously provide an input consisting of only null bytes, strcmp will treat them as matching — allowing us to bypass the security check.
Here is the Exploitation Script1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #!/usr/bin/env python3 from pwn import * elf = ELF(&#34;./terminal_patched&#34;) libc = ELF(&#34;./libc.so.6&#34;) ld = ELF(&#34;./ld-linux-x86-64.so.2&#34;) context.binary = elf r = remote(&#39;20.84.72.194&#39;, &#39;5005&#39;) # r = process() # gdb.attach(r,gdbscript=&#39;b userinfo&#39;) r.sendlineafter(b&#39;First Name Length: &#39;,f&#39;{8392928-23}&#39;) #-23 because the program is adding 23 r.sendlineafter(b&#39;Surname Length: &#39;,str(0x400-23).encode()) r.sendlineafter(b&#39;First Name:&#39;,b&#39;\x00&#39;*0x20&#43;b&#39;\n&#39;) ##### filling the name/flag buffer with null r.sendlineafter(b&#39;Surname:&#39;,b&#39;\x00&#39;*0x10&#43;b&#39;\n&#39;) r.sendlineafter(b&#39;Enter security token:&#39;,b&#39;\x00&#39;*100&#43;b&#39;\n&#39;) r.interactive() 🐿️ SummaryHere’s a quick summary for time-pressed readers
The core idea was about multithreading: two threads, userinfo and auth, running side by side.
userinfo asked for your name and allocated memory on the stack using alloca. auth read the flag into its own stack buffer and waited for userinfo to finish. On remote, the thread stacks were contiguous — only a tiny guard page separating them.
Using alloca, we could allocate a massive buffer in userinfo and overflow into auth’s stack, right where the flag was stored!
we could overwrite the start of the flag buffer with null bytes. Since strcmp stops at the first null, it would treat our null-filled input as matching — and trigger a shell.
Useful linkshttps://www.scaler.com/topics/multithreading-in-c/
https://www.codequoi.com/en/threads-mutexes-and-concurrent-programming-in-c/
🔗 Connect with me:GitHub twitter">
  <meta itemprop="datePublished" content="2025-06-20T03:21:46+05:30">
  <meta itemprop="dateModified" content="2025-06-20T03:21:46+05:30">
  <meta itemprop="wordCount" content="1605">
  <meta itemprop="keywords" content="Threads,Processes"><meta property="og:url" content="http://localhost:1313/d1ff/posts/squirrel_writeup/logon/">
  <meta property="og:site_name" content="d1ff">
  <meta property="og:title" content="Squ1rrelCTF 2025 writeup (pwn/Squ1rrel_logon)">
  <meta property="og:description" content="Over the weekend, I teamed up with my friends to play SquirrelCTF.
The event was amazing, and the pwn challenges in particular really stood out — they forced us to think hard, connect clues, and improve our skills.
hereby I will be delivering a detailed writeup of the logon challenge.
Before diving deeper, let’s take a quick moment to understand the concept of Threading.
CONCURRENT PROGRAMMINGAs the name suggests, concurrent programming is all about doing multiple things at once. “Concurrent” means happening simultaneously, and “programming”—well, you already know that part 😉.
Concurrent programming allows a program to perform several tasks simultaneously instead of having to wait for the result of one operation to move onto the next.
There are three ways to implement concurrency in our programs: processes, threads, and multiplexing. Let’s concentrate on threads.
THREADINGAn execution thread is a logical sequence of instructions inside a process that is automatically managed by the operating system’s kernel. A regular sequential program has a single thread, but modern operating systems allow us to create several threads in our programs, all of which run in parallel.
Each one of a process’s threads has its own context: its own thread ID, its own stack, its own instruction pointer, it’s own processor register .
BUT since all of the thread are part of the same process, they share the same VIRTUAL MEMORY ADDRESS SPACE : the same code, the same heap, the same shared libraries and the same open file descriptors.
As shown in the image, threads from the same process share the code, data, and files, but each one gets its own stack to work with.
Let’s look at a simple c program that uses threading.1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include &lt;stdio.h&gt; #include &lt;pthread.h&gt; // This is the function that the thread will run void* myThreadFunction(void* arg) { printf(&#34;Hello from the thread!\n&#34;); return NULL; } int main() { pthread_t thread; // Create a new thread that runs myThreadFunction if (pthread_create(&amp;thread, NULL, myThreadFunction, NULL) != 0) { perror(&#34;Failed to create thread&#34;); return 1; } // Wait for the thread to finish if (pthread_join(thread, NULL) != 0) { perror(&#34;Failed to join thread&#34;); return 1; } printf(&#34;Thread has finished execution.\n&#34;); return 0; } To compile and run the program—&gt; gcc -o simple_thread simple_thread.c -pthread
`./simple_thread`Lets look at some of the useful syntax here :-
pthread_tThis is just a data type (basically like an int or a struct) that is used to store the ID of a thread. When you create a thread, you need a pthread_t variable to hold a reference to that thread so you can interact with it later (e.g., wait for it to finish). pthread_createThis creates a new thread. It starts running a function you specify — in parallel with your main() function. 1 int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg); pthread_joinThis waits for a thread to finish. It blocks (pauses) your main() program until the specified thread is done running. 1 int pthread_join(pthread_t thread, void **retval); A visual map of the program above
1 2 3 4 5 6 main() starts | |--&gt; pthread_create --&gt; myThreadFunction() runs in parallel | |--&gt; pthread_join --&gt; wait until myThreadFunction() is done main() continues after join here is the virtual memory map of the above process.Before pthread_create is being called
After pthread_create is being called
Now since we have learnt all the requisites to understand the source code of the pwn_logon binary.
lets first have a look of the decompiled binary.
This is the main fucntion.
First, it disables buffering on stdout and stdin using setbuf (this can be ignored for now).
Then it prints a banner by calling the print_banner function (also not important here).
After that:
At line 6, it creates a thread that runs the userinfo function. At line 7, it creates another thread that runs the auth function. Finally, it waits for the auth_thread to finish execution using pthread_join, and then the program exits.
ALL good HERE
This is the userinfo function.
lets see!!
The userinfo function first asks the user for the length of their first name and surname.
It then uses alloca to allocate memory after paddig the size with blocks of 16 bytes , for both names on the stack, based on the provided lengths, and reads in the names using readline.
At first glance, this looks simple.
But there’s a lurking vulnerability:
alloca is a C built-in function that allocates memory dynamically on the stack, not on the heap.
In a thread (like here), the stack size is fixed when the thread is created. It’s usually around 0x8000 bytes (or 0x10000 bytes), depending on system and settings.
Since the function explicitly asks the user for the name and surname sizes, and only enforces that length &lt; 0x100000000 (i.e., under 4GB, which is huge), the user can request very large allocations.
If the combined size of allocations exceeds the thread’s stack limit, this can lead to a stack overflow inside the thread.
🧠 keep this vuln in mind it may be useful later for exploitation.
This is auth function.
Here’s where the real objective becomes clear:
The auth function:
Opens the file flag.txt and reads its contents into a stack buffer (inside the auth thread’s stack). Then it waits for the userinfo_thread to complete by calling pthread_join. After that, it prompts the user to enter a security token. The program then compares the user input against the contents read from flag.txt.
If the strings match, it calls system(&#34;/bin/sh&#34;) and gives shell access. Otherwise, it prints an ACCESS DENIED message and terminates. Now since we have understood what the program is doing let’s take a look on virtual memory mapping of it with the help of gdb-pwndbg .
As we observed in the main function, the auth_thread is created after the userinfo_thread.
By default, new thread stacks are allocated at lower memory addresses than those of previously created threads.
Looking at the memory layout here, we notice:
There is a guard page (0x1000 bytes = 1 page) between the two thread stacks, protecting them from each other. However, between the end of auth_thread’s stack and the second guard page, there is a large gap of 0x1ff000 bytes locally. 💡Interestingly, when running on the remote instance, I observed that this gap was absent — meaning the guard pages and thread stacks are fully contiguous on the remote server.
The decompilation is performed using ida8.9
🤔 EXPLOITATION ROUTETime to activate the hippocampus and connect the dots. 🧠
We know there’s a potential stack overflow in the userinfo thread, and that the auth function runs in parallel (more precisely, concurrently).
If we look carefully:
In auth, the contents of flag.txt are read into a stack buffer early on. After reading, auth calls pthread_join to wait for userinfo_thread to finish. Important: At the time we are writing our name and surname in userinfo, the buffer inside auth is already populated. This opens an opportunity:
If we can leak or overwrite the auth thread’s buffer, we can control the value used in the strcmp check. If we can make the comparison pass, we can trigger system(&#34;/bin/sh&#34;) and get a shell. Now, recall another crucial observation:
The stack regions for userinfo_thread and auth_thread are aligned and adjacent (next to each other) in memory. Thus, if we:
Allocate a large enough name or surname buffer inside userinfo (using alloca), The allocation can spill over into the auth_thread’s stack region, especially the part where the flag.txt buffer is stored. Using gdb-pwndbg, I determined that the offset between the base address of the name_buffer (allocated in userinfo_thread) and the auth thread’s buffer is approximately 8,392,928 bytes — assuming the memory between the two thread stacks is contiguous.
💡Another cool property of strcmpis that it compares two strings character-by-character until it encounters a null byte (\0). In C, strings are null-terminated, so strcmp effectively stops checking as soon as it hits the first null byte.
This means if we manage to overwrite the beginning of the flag buffer with null bytes , and simultaneously provide an input consisting of only null bytes, strcmp will treat them as matching — allowing us to bypass the security check.
Here is the Exploitation Script1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #!/usr/bin/env python3 from pwn import * elf = ELF(&#34;./terminal_patched&#34;) libc = ELF(&#34;./libc.so.6&#34;) ld = ELF(&#34;./ld-linux-x86-64.so.2&#34;) context.binary = elf r = remote(&#39;20.84.72.194&#39;, &#39;5005&#39;) # r = process() # gdb.attach(r,gdbscript=&#39;b userinfo&#39;) r.sendlineafter(b&#39;First Name Length: &#39;,f&#39;{8392928-23}&#39;) #-23 because the program is adding 23 r.sendlineafter(b&#39;Surname Length: &#39;,str(0x400-23).encode()) r.sendlineafter(b&#39;First Name:&#39;,b&#39;\x00&#39;*0x20&#43;b&#39;\n&#39;) ##### filling the name/flag buffer with null r.sendlineafter(b&#39;Surname:&#39;,b&#39;\x00&#39;*0x10&#43;b&#39;\n&#39;) r.sendlineafter(b&#39;Enter security token:&#39;,b&#39;\x00&#39;*100&#43;b&#39;\n&#39;) r.interactive() 🐿️ SummaryHere’s a quick summary for time-pressed readers
The core idea was about multithreading: two threads, userinfo and auth, running side by side.
userinfo asked for your name and allocated memory on the stack using alloca. auth read the flag into its own stack buffer and waited for userinfo to finish. On remote, the thread stacks were contiguous — only a tiny guard page separating them.
Using alloca, we could allocate a massive buffer in userinfo and overflow into auth’s stack, right where the flag was stored!
we could overwrite the start of the flag buffer with null bytes. Since strcmp stops at the first null, it would treat our null-filled input as matching — and trigger a shell.
Useful linkshttps://www.scaler.com/topics/multithreading-in-c/
https://www.codequoi.com/en/threads-mutexes-and-concurrent-programming-in-c/
🔗 Connect with me:GitHub twitter">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-06-20T03:21:46+05:30">
    <meta property="article:modified_time" content="2025-06-20T03:21:46+05:30">
    <meta property="article:tag" content="Threads">
    <meta property="article:tag" content="Processes">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Squ1rrelCTF 2025 writeup (pwn/Squ1rrel_logon)">
  <meta name="twitter:description" content="Over the weekend, I teamed up with my friends to play SquirrelCTF.
The event was amazing, and the pwn challenges in particular really stood out — they forced us to think hard, connect clues, and improve our skills.
hereby I will be delivering a detailed writeup of the logon challenge.
Before diving deeper, let’s take a quick moment to understand the concept of Threading.
CONCURRENT PROGRAMMINGAs the name suggests, concurrent programming is all about doing multiple things at once. “Concurrent” means happening simultaneously, and “programming”—well, you already know that part 😉.
Concurrent programming allows a program to perform several tasks simultaneously instead of having to wait for the result of one operation to move onto the next.
There are three ways to implement concurrency in our programs: processes, threads, and multiplexing. Let’s concentrate on threads.
THREADINGAn execution thread is a logical sequence of instructions inside a process that is automatically managed by the operating system’s kernel. A regular sequential program has a single thread, but modern operating systems allow us to create several threads in our programs, all of which run in parallel.
Each one of a process’s threads has its own context: its own thread ID, its own stack, its own instruction pointer, it’s own processor register .
BUT since all of the thread are part of the same process, they share the same VIRTUAL MEMORY ADDRESS SPACE : the same code, the same heap, the same shared libraries and the same open file descriptors.
As shown in the image, threads from the same process share the code, data, and files, but each one gets its own stack to work with.
Let’s look at a simple c program that uses threading.1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include &lt;stdio.h&gt; #include &lt;pthread.h&gt; // This is the function that the thread will run void* myThreadFunction(void* arg) { printf(&#34;Hello from the thread!\n&#34;); return NULL; } int main() { pthread_t thread; // Create a new thread that runs myThreadFunction if (pthread_create(&amp;thread, NULL, myThreadFunction, NULL) != 0) { perror(&#34;Failed to create thread&#34;); return 1; } // Wait for the thread to finish if (pthread_join(thread, NULL) != 0) { perror(&#34;Failed to join thread&#34;); return 1; } printf(&#34;Thread has finished execution.\n&#34;); return 0; } To compile and run the program—&gt; gcc -o simple_thread simple_thread.c -pthread
`./simple_thread`Lets look at some of the useful syntax here :-
pthread_tThis is just a data type (basically like an int or a struct) that is used to store the ID of a thread. When you create a thread, you need a pthread_t variable to hold a reference to that thread so you can interact with it later (e.g., wait for it to finish). pthread_createThis creates a new thread. It starts running a function you specify — in parallel with your main() function. 1 int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg); pthread_joinThis waits for a thread to finish. It blocks (pauses) your main() program until the specified thread is done running. 1 int pthread_join(pthread_t thread, void **retval); A visual map of the program above
1 2 3 4 5 6 main() starts | |--&gt; pthread_create --&gt; myThreadFunction() runs in parallel | |--&gt; pthread_join --&gt; wait until myThreadFunction() is done main() continues after join here is the virtual memory map of the above process.Before pthread_create is being called
After pthread_create is being called
Now since we have learnt all the requisites to understand the source code of the pwn_logon binary.
lets first have a look of the decompiled binary.
This is the main fucntion.
First, it disables buffering on stdout and stdin using setbuf (this can be ignored for now).
Then it prints a banner by calling the print_banner function (also not important here).
After that:
At line 6, it creates a thread that runs the userinfo function. At line 7, it creates another thread that runs the auth function. Finally, it waits for the auth_thread to finish execution using pthread_join, and then the program exits.
ALL good HERE
This is the userinfo function.
lets see!!
The userinfo function first asks the user for the length of their first name and surname.
It then uses alloca to allocate memory after paddig the size with blocks of 16 bytes , for both names on the stack, based on the provided lengths, and reads in the names using readline.
At first glance, this looks simple.
But there’s a lurking vulnerability:
alloca is a C built-in function that allocates memory dynamically on the stack, not on the heap.
In a thread (like here), the stack size is fixed when the thread is created. It’s usually around 0x8000 bytes (or 0x10000 bytes), depending on system and settings.
Since the function explicitly asks the user for the name and surname sizes, and only enforces that length &lt; 0x100000000 (i.e., under 4GB, which is huge), the user can request very large allocations.
If the combined size of allocations exceeds the thread’s stack limit, this can lead to a stack overflow inside the thread.
🧠 keep this vuln in mind it may be useful later for exploitation.
This is auth function.
Here’s where the real objective becomes clear:
The auth function:
Opens the file flag.txt and reads its contents into a stack buffer (inside the auth thread’s stack). Then it waits for the userinfo_thread to complete by calling pthread_join. After that, it prompts the user to enter a security token. The program then compares the user input against the contents read from flag.txt.
If the strings match, it calls system(&#34;/bin/sh&#34;) and gives shell access. Otherwise, it prints an ACCESS DENIED message and terminates. Now since we have understood what the program is doing let’s take a look on virtual memory mapping of it with the help of gdb-pwndbg .
As we observed in the main function, the auth_thread is created after the userinfo_thread.
By default, new thread stacks are allocated at lower memory addresses than those of previously created threads.
Looking at the memory layout here, we notice:
There is a guard page (0x1000 bytes = 1 page) between the two thread stacks, protecting them from each other. However, between the end of auth_thread’s stack and the second guard page, there is a large gap of 0x1ff000 bytes locally. 💡Interestingly, when running on the remote instance, I observed that this gap was absent — meaning the guard pages and thread stacks are fully contiguous on the remote server.
The decompilation is performed using ida8.9
🤔 EXPLOITATION ROUTETime to activate the hippocampus and connect the dots. 🧠
We know there’s a potential stack overflow in the userinfo thread, and that the auth function runs in parallel (more precisely, concurrently).
If we look carefully:
In auth, the contents of flag.txt are read into a stack buffer early on. After reading, auth calls pthread_join to wait for userinfo_thread to finish. Important: At the time we are writing our name and surname in userinfo, the buffer inside auth is already populated. This opens an opportunity:
If we can leak or overwrite the auth thread’s buffer, we can control the value used in the strcmp check. If we can make the comparison pass, we can trigger system(&#34;/bin/sh&#34;) and get a shell. Now, recall another crucial observation:
The stack regions for userinfo_thread and auth_thread are aligned and adjacent (next to each other) in memory. Thus, if we:
Allocate a large enough name or surname buffer inside userinfo (using alloca), The allocation can spill over into the auth_thread’s stack region, especially the part where the flag.txt buffer is stored. Using gdb-pwndbg, I determined that the offset between the base address of the name_buffer (allocated in userinfo_thread) and the auth thread’s buffer is approximately 8,392,928 bytes — assuming the memory between the two thread stacks is contiguous.
💡Another cool property of strcmpis that it compares two strings character-by-character until it encounters a null byte (\0). In C, strings are null-terminated, so strcmp effectively stops checking as soon as it hits the first null byte.
This means if we manage to overwrite the beginning of the flag buffer with null bytes , and simultaneously provide an input consisting of only null bytes, strcmp will treat them as matching — allowing us to bypass the security check.
Here is the Exploitation Script1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #!/usr/bin/env python3 from pwn import * elf = ELF(&#34;./terminal_patched&#34;) libc = ELF(&#34;./libc.so.6&#34;) ld = ELF(&#34;./ld-linux-x86-64.so.2&#34;) context.binary = elf r = remote(&#39;20.84.72.194&#39;, &#39;5005&#39;) # r = process() # gdb.attach(r,gdbscript=&#39;b userinfo&#39;) r.sendlineafter(b&#39;First Name Length: &#39;,f&#39;{8392928-23}&#39;) #-23 because the program is adding 23 r.sendlineafter(b&#39;Surname Length: &#39;,str(0x400-23).encode()) r.sendlineafter(b&#39;First Name:&#39;,b&#39;\x00&#39;*0x20&#43;b&#39;\n&#39;) ##### filling the name/flag buffer with null r.sendlineafter(b&#39;Surname:&#39;,b&#39;\x00&#39;*0x10&#43;b&#39;\n&#39;) r.sendlineafter(b&#39;Enter security token:&#39;,b&#39;\x00&#39;*100&#43;b&#39;\n&#39;) r.interactive() 🐿️ SummaryHere’s a quick summary for time-pressed readers
The core idea was about multithreading: two threads, userinfo and auth, running side by side.
userinfo asked for your name and allocated memory on the stack using alloca. auth read the flag into its own stack buffer and waited for userinfo to finish. On remote, the thread stacks were contiguous — only a tiny guard page separating them.
Using alloca, we could allocate a massive buffer in userinfo and overflow into auth’s stack, right where the flag was stored!
we could overwrite the start of the flag buffer with null bytes. Since strcmp stops at the first null, it would treat our null-filled input as matching — and trigger a shell.
Useful linkshttps://www.scaler.com/topics/multithreading-in-c/
https://www.codequoi.com/en/threads-mutexes-and-concurrent-programming-in-c/
🔗 Connect with me:GitHub twitter">
      <meta name="twitter:site" content="@Anuj1337">
<meta name="twitter:creator" content="@Anuj1337" /><meta name="application-name" content="FixIt">
<meta name="apple-mobile-web-app-title" content="FixIt"><meta name="theme-color" data-light="#f8f8f8" data-dark="#252627" content="#f8f8f8"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="http://localhost:1313/d1ff/favicon.ico" />
    <link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/d1ff/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/d1ff/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="http://localhost:1313/d1ff/apple-touch-icon.png"><link rel="mask-icon" href="http://localhost:1313/d1ff/safari-pinned-tab.svg" color="#5bbad5"><link rel="canonical" type="text/html" href="http://localhost:1313/d1ff/posts/squirrel_writeup/logon/" title="Squ1rrelCTF 2025 writeup (pwn/Squ1rrel_logon) - d1ff" /><link rel="next" type="text/html" href="http://localhost:1313/d1ff/posts/smiley_writeup/limit/" title="SmileyCTF 2025 writeup (pwn/limit)" /><link rel="alternate" type="text/markdown" href="http://localhost:1313/d1ff/posts/squirrel_writeup/logon/index.md" title="Squ1rrelCTF 2025 writeup (pwn/Squ1rrel_logon) - d1ff"><link rel="stylesheet" href="http://localhost:1313/d1ff/css/style.min.css"><link rel="preload" href="http://localhost:1313/d1ff/lib/fontawesome-free/all.min.css" as="style" onload="this.removeAttribute('onload');this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="http://localhost:1313/d1ff/lib/fontawesome-free/all.min.css"></noscript><link rel="preload" href="http://localhost:1313/d1ff/lib/animate/animate.min.css" as="style" onload="this.removeAttribute('onload');this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="http://localhost:1313/d1ff/lib/animate/animate.min.css"></noscript><script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "headline": "Squ1rrelCTF 2025 writeup (pwn/Squ1rrel_logon)",
    "inLanguage": "en-us",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "http:\/\/localhost:1313\/d1ff\/posts\/squirrel_writeup\/logon\/"
    },"genre": "posts","keywords": "Threads, Processes","wordcount":  1605 ,
    "url": "http:\/\/localhost:1313\/d1ff\/posts\/squirrel_writeup\/logon\/","datePublished": "2025-06-20T03:21:46+05:30","dateModified": "2025-06-20T03:21:46+05:30","publisher": {
      "@type": "Organization",
      "name": ""},"author": {
        "@type": "Person",
        "name": "_d1ff"
      },"description": ""
  }
  </script><script src="http://localhost:1313/d1ff/js/head/color-scheme.min.js"></script></head>
  <body data-header-desktop="sticky" data-header-mobile="auto"><div class="wrapper" data-page-style="normal"><header class="desktop animate__faster" id="header-desktop">
  <div class="header-wrapper">
    <div class="header-title">
      <a href="http://localhost:1313/d1ff/" title="d1ff"><img class="logo" src='http://localhost:1313/d1ff/images/me.jpg' alt="d1ff" height="32" width="32"><span class="header-title-text">d1ff</span></a><span class="header-subtitle"></span></div>
    <nav>
      <ul class="menu"><li class="menu-item">
              <a class="menu-link" href="http://localhost:1313/d1ff/archives/"><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden="true"></i> Archives</a></li><li class="menu-item">
              <a class="menu-link" href="http://localhost:1313/d1ff/categories/"><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden="true"></i> Categories</a></li><li class="menu-item">
              <a class="menu-link" href="http://localhost:1313/d1ff/tags/"><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden="true"></i> Tags</a></li><li class="menu-item delimiter"></li><li class="menu-item theme-switch" title="Switch Theme">
          <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
        </li></ul>
    </nav>
  </div>
</header><header class="mobile animate__faster" id="header-mobile">
  <div class="header-container">
    <div class="header-wrapper">
      <div class="header-title">
        <a href="http://localhost:1313/d1ff/" title="d1ff"><img class="logo" src='http://localhost:1313/d1ff/images/me.jpg' alt="d1ff" height="26" width="26"><span class="header-title-text">d1ff</span></a><span class="header-subtitle"></span></div>
      <div class="menu-toggle" id="menu-toggle-mobile">
        <span></span><span></span><span></span>
      </div>
    </div>
    <nav>
      <ul class="menu" id="menu-mobile"><li class="menu-item"><a class="menu-link" href="http://localhost:1313/d1ff/archives/"><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden="true"></i> Archives</a></li><li class="menu-item"><a class="menu-link" href="http://localhost:1313/d1ff/categories/"><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden="true"></i> Categories</a></li><li class="menu-item"><a class="menu-link" href="http://localhost:1313/d1ff/tags/"><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden="true"></i> Tags</a></li><li class="menu-item menu-system">
          <span class="menu-system-item theme-switch" title="Switch Theme"><i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i></span></li>
      </ul>
    </nav>
  </div>
</header><main class="container"><aside class="aside-collection animate__animated animate__fadeIn animate__faster" aria-label="Collections"></aside>

  <article class="page single">
    <div class="header"><h1 class="single-title animate__animated animate__flipInX"><span title="Repost" class="icon-repost"><i class="fa-solid fa-share fa-fw" aria-hidden="true"></i></span><span>Squ1rrelCTF 2025 Writeup (Pwn/Squ1rrel_logon)</span>
      </h1></div><div class="post-meta">
      <div class="post-meta-line"><span class="post-author"><a href="https://discord.com/users/1157208253055381504" title="Author"target="_blank" rel="external nofollow noopener noreferrer author" class="author"><img class="avatar" src='http://localhost:1313/d1ff/images/me.jpg' alt="_d1ff" height="16" width="16">&nbsp;_d1ff</a></span><span class="post-included-in">&nbsp;included in <a href="http://localhost:1313/d1ff/categories/pwning/" class="post-category" title="Category - Pwning"><i class="fa-regular fa-folder fa-fw" aria-hidden="true"></i> Pwning</a></span></div><div class="post-meta-line"><span title="published on 2025-06-20 03:21:46"><i class="fa-solid fa-calendar-days fa-fw me-1" aria-hidden="true"></i><time datetime="2025-06-20">2025-06-20</time></span>&nbsp;<span title="1605 words"><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden="true"></i>About 1700 words</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden="true"></i>8 minutes</span>&nbsp;</div>
    </div><div class="details toc" id="toc-static" data-kept="false">
        <div class="details-summary toc-title">
          <span>Contents</span>
          <span><i class="details-icon fa-solid fa-angle-right" aria-hidden="true"></i></span>
        </div>
        <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#concurrent-programming">CONCURRENT PROGRAMMING</a></li>
        <li><a href="#threading">THREADING</a></li>
        <li><a href="#lets-look-at-a-simple-c-program-that-uses-threading">Let’s look at a simple c program that uses threading.</a></li>
        <li><a href="#pthread_t"><code>pthread_t</code></a></li>
        <li><a href="#pthread_create"><code>pthread_create</code></a></li>
        <li><a href="#pthread_join"><code>pthread_join</code></a></li>
        <li><a href="#here-is-the-virtual-memory-map-of-the-above-process">here is the virtual memory map of the above process.</a></li>
      </ul>
    </li>
    <li><a href="#-exploitation-route">🤔 EXPLOITATION ROUTE</a></li>
    <li><a href="#here-is-the-exploitation-script">Here is the Exploitation Script</a></li>
    <li><a href="#-summary">🐿️ Summary</a>
      <ul>
        <li><a href="#useful-links">Useful links</a></li>
        <li><a href="#-connect-with-me">🔗 Connect with me:</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
      </div><div class="content" id="content"><p>Over the weekend, I teamed up with my friends to play <strong>SquirrelCTF</strong>.</p>
<p>The event was amazing, and the <strong>pwn challenges</strong> in particular really stood out — they forced us to think hard, connect  clues, and improve our skills.</p>
<p>hereby I will be delivering a detailed writeup of the <code>logon</code> challenge.</p>
<p>Before diving deeper, let’s take a quick moment to understand the concept of <strong>Threading</strong>.</p>
<h3 class="heading-element" id="concurrent-programming"><span>CONCURRENT PROGRAMMING</span>
  <a href="#concurrent-programming" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>As the name suggests, <strong>concurrent programming</strong> is all about doing multiple things at once. <em>&ldquo;Concurrent&rdquo;</em> means happening simultaneously, and <em>&ldquo;programming&rdquo;</em>—well, you already know that part 😉.</p>
<p><strong>Concurrent programming</strong> allows a program to perform several tasks simultaneously instead of having to wait for the result of one operation to move onto the next.</p>
<p>There are three ways to implement concurrency in our programs: <code>processes</code>, <code>threads</code>, and <code>multiplexing</code>. Let’s concentrate on threads.</p>
<h3 class="heading-element" id="threading"><span>THREADING</span>
  <a href="#threading" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p>An execution <strong>thread</strong> is a logical sequence of instructions inside a process that is automatically managed by the operating system’s kernel. A regular sequential program has a single thread, but modern operating systems allow us to create several threads in our programs, all of which run in parallel.</p>
<p>Each one of a process’s threads has its own context: its own <code>thread ID</code>, <code>its own stack</code>, <code>its own instruction pointer</code>, <code>it’s own processor register</code> .</p>
<p>BUT since all of the thread are part of the same process, they share the same <strong><code>VIRTUAL MEMORY ADDRESS SPACE</code></strong> :  the same <code>code</code>, the same <code>heap</code>, the same <code>shared libraries</code> and the same <code>open file descriptors</code>.</p>
<p><img loading="lazy" src='http://localhost:1313/d1ff/images/image.png' alt="image.png"></p>
<p><em>As shown in the image, threads from the same process <strong>share the code, data, and files</strong>, but each one gets its <strong>own stack</strong> to work with.</em></p>
<h3 class="heading-element" id="lets-look-at-a-simple-c-program-that-uses-threading"><span>Let’s look at a simple c program that uses threading.</span>
  <a href="#lets-look-at-a-simple-c-program-that-uses-threading" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// This is the function that the thread will run
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span><span class="o">*</span> <span class="nf">myThreadFunction</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Hello from the thread!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">pthread_t</span> <span class="kr">thread</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Create a new thread that runs myThreadFunction
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nf">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="kr">thread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">myThreadFunction</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">perror</span><span class="p">(</span><span class="s">&#34;Failed to create thread&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Wait for the thread to finish
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="nf">pthread_join</span><span class="p">(</span><span class="kr">thread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">perror</span><span class="p">(</span><span class="s">&#34;Failed to join thread&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Thread has finished execution.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>To compile and run the program—&gt; <code>gcc -o simple_thread simple_thread.c -pthread</code></p>
<pre><code>                                                                `./simple_thread`
</code></pre>
<p><strong>Lets look at some of the useful syntax here :-</strong></p>
<h3 class="heading-element" id="pthread_t"><span><code>pthread_t</code></span>
  <a href="#pthread_t" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>This is just a <strong>data type</strong> (basically like an <code>int</code> or a <code>struct</code>) that is used to <strong>store the ID</strong> of a thread.</li>
<li>When you create a thread, you need a <code>pthread_t</code> variable to hold a reference to that thread so you can interact with it later (e.g., wait for it to finish).</li>
</ul>
<h3 class="heading-element" id="pthread_create"><span><code>pthread_create</code></span>
  <a href="#pthread_create" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>This <strong>creates a new thread</strong>.</li>
<li>It <strong>starts running</strong> a function you specify — in parallel with your <code>main()</code> function.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">pthread_create</span><span class="p">(</span><span class="kt">pthread_t</span> <span class="o">*</span><span class="kr">thread</span><span class="p">,</span> <span class="k">const</span> <span class="kt">pthread_attr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">start_routine</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 class="heading-element" id="pthread_join"><span><code>pthread_join</code></span>
  <a href="#pthread_join" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li>This <strong>waits</strong> for a <strong>thread to finish</strong>.</li>
<li>It <strong>blocks</strong> (pauses) your <code>main()</code> program until the specified thread is done running.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">pthread_join</span><span class="p">(</span><span class="kt">pthread_t</span> <span class="kr">thread</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">retval</span><span class="p">);</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p><em><strong>A visual map of the program above</strong></em></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nf">main</span><span class="p">()</span> <span class="n">starts</span>
</span></span><span class="line"><span class="cl">    <span class="o">|</span>
</span></span><span class="line"><span class="cl">    <span class="o">|--&gt;</span> <span class="n">pthread_create</span> <span class="o">--&gt;</span> <span class="nf">myThreadFunction</span><span class="p">()</span> <span class="n">runs</span> <span class="n">in</span> <span class="n">parallel</span>
</span></span><span class="line"><span class="cl">    <span class="o">|</span>
</span></span><span class="line"><span class="cl">    <span class="o">|--&gt;</span> <span class="n">pthread_join</span> <span class="o">--&gt;</span> <span class="n">wait</span> <span class="n">until</span> <span class="nf">myThreadFunction</span><span class="p">()</span> <span class="n">is</span> <span class="n">done</span>
</span></span><span class="line"><span class="cl"><span class="nf">main</span><span class="p">()</span> <span class="n">continues</span> <span class="n">after</span> <span class="n">join</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 class="heading-element" id="here-is-the-virtual-memory-map-of-the-above-process"><span>here is the virtual memory map of the above process.</span>
  <a href="#here-is-the-virtual-memory-map-of-the-above-process" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p><em><strong>Before</strong></em> <code>pthread_create</code> is being called</p>
<p><img loading="lazy" src='http://localhost:1313/d1ff/images/Screenshot_from_2025-04-18_15-16-40.png' alt="Screenshot from 2025-04-18 15-16-40.png"></p>
<p><em><strong>After</strong></em> <code>pthread_create</code> is being called</p>
<p><img loading="lazy" src='http://localhost:1313/d1ff/images/guard_page.png' alt="guard page.png"></p>
<hr>
<p>Now since we have learnt all the requisites to understand the source code of the <code>pwn_logon</code> binary.</p>
<p>lets first have a look of the decompiled binary.</p>
<img src="http://localhost:1313/d1ff/images/cbee3a58-b22a-4799-9248-4c915289a943.png" width="600" />
<!-- ![mkmdfl;v.png](/images_logon/cbee3a58-b22a-4799-9248-4c915289a943.png) -->
<p>This is the <code>main</code> fucntion.</p>
<p><img loading="lazy" src='http://localhost:1313/d1ff/images/Screenshot_from_2025-04-10_15-51-47.png' alt="Screenshot from 2025-04-10 15-51-47.png"></p>
<blockquote>
<p>First, it disables buffering on <code>stdout</code> and <code>stdin</code> using <code>setbuf</code> (this can be ignored for now).</p></blockquote>
<blockquote>
<p>Then it prints a banner by calling the <code>print_banner</code> function (also not important here).</p></blockquote>
<p>After that:</p>
<ul>
<li>At line 6, it <strong>creates a thread</strong> that runs the <code>userinfo</code> function.</li>
<li>At line 7, it <strong>creates another thread</strong> that runs the <code>auth</code> function.</li>
</ul>
<blockquote>
<p>Finally, it <strong>waits</strong> for the <code>auth_thread</code> to finish execution using <code>pthread_join</code>, and then the program exits.</p></blockquote>
<p><code>ALL good HERE</code></p>
<hr>
<p>This is the <code>userinfo</code> function.</p>
<p><img loading="lazy" src='http://localhost:1313/d1ff/images/Screenshot_from_2025-04-10_15-52-17.png' alt="Screenshot from 2025-04-10 15-52-17.png"></p>
<blockquote>
<p>lets see!!</p>
<p>The <code>userinfo</code> function first asks the user for the <strong>length</strong> of their <strong>first name</strong> and <strong>surname</strong>.</p>
<p>It then uses <code>alloca</code> to allocate memory  after paddig the size with blocks of 16 bytes , for both names <strong>on the stack</strong>, based on the provided lengths, and reads in the names using <code>readline</code>.</p>
<p><strong>At first glance, this looks simple.</strong></p>
<hr>
<p><strong>But there’s a lurking vulnerability:</strong></p>
<p><code>alloca</code> is a C built-in function that <strong>allocates memory dynamically on the stack</strong>, <em>not</em> on the heap.</p>
<p>In a thread (like here), the <strong>stack size is fixed</strong> when the thread is created. It’s usually around <strong>0x8000 bytes</strong> (or <strong>0x10000 bytes</strong>), depending on system and settings.</p>
<p>Since the function <strong>explicitly asks the user</strong> for the name and surname sizes, and only enforces that <code>length &lt; 0x100000000</code> (i.e., under 4GB, which is huge), <strong>the user can request very large allocations</strong>.</p>
<p>If the combined size of allocations <strong>exceeds the thread’s stack limit</strong>, this can lead to a <strong>stack overflow</strong> inside the thread.</p></blockquote>
<p><em><strong>🧠 keep this vuln in mind it may be useful later for exploitation.</strong></em></p>
<hr>
<p>This is <code>auth</code> function.</p>
<p><img loading="lazy" src='http://localhost:1313/d1ff/images/Screenshot_from_2025-04-10_15-52-05.png' alt="Screenshot from 2025-04-10 15-52-05.png"></p>
<p>Here&rsquo;s where the real objective becomes clear:</p>
<p>The <code>auth</code> function:</p>
<ul>
<li>Opens the file <code>flag.txt</code> and reads its contents into a <strong>stack buffer</strong> (inside the <code>auth</code> thread’s stack).</li>
<li>Then it waits for the <code>userinfo_thread</code> to complete by calling <code>pthread_join</code>.</li>
<li>After that, it prompts the user to <strong>enter a security token</strong>.</li>
</ul>
<p>The program then compares the user input against the contents read from <code>flag.txt</code>.</p>
<ul>
<li>If the strings <strong>match</strong>, it calls <code>system(&quot;/bin/sh&quot;)</code> and gives shell access.</li>
<li>Otherwise, it prints an <strong>ACCESS DENIED</strong> message and terminates.</li>
</ul>
<hr>
<p>Now since we have understood what the program is doing let’s take a look on virtual memory mapping of it with the help of <code>gdb-pwndbg</code> .</p>
<p><img loading="lazy" src='http://localhost:1313/d1ff/images/auth_thread.png' alt="auth_thread.png"></p>
<blockquote>
<p>As we observed in the <code>main</code> function, the <code>auth_thread</code> is created <strong>after</strong> the <code>userinfo_thread</code>.</p></blockquote>
<blockquote>
<p>By default, <strong>new thread stacks are allocated at lower memory addresses</strong> than those of previously created threads.</p></blockquote>
<p>Looking at the memory layout here, we notice:</p>
<ul>
<li>There is a <strong>guard page</strong> (0x1000 bytes = 1 page) between the two thread stacks, protecting them from each other.</li>
<li>However, between the end of <code>auth_thread</code>&rsquo;s stack and the second guard page, there is a <strong>large gap</strong> of <code>0x1ff000</code> bytes locally.</li>
</ul>
<aside>
💡
<p>Interestingly, when running on the <strong>remote instance</strong>, I observed that this gap was <strong>absent</strong> — meaning the <strong>guard pages and thread stacks are fully contiguous</strong> on the remote server.</p>
</aside>
<p><em>The decompilation is performed using ida8.9</em></p>
<h2 class="heading-element" id="-exploitation-route"><span>🤔 EXPLOITATION ROUTE</span>
  <a href="#-exploitation-route" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>Time to activate the hippocampus and connect the dots. 🧠</p>
<p>We know there’s a <strong>potential stack overflow</strong> in the <code>userinfo</code> thread, and that the <code>auth</code> function runs <strong>in parallel</strong> (more precisely, concurrently).</p>
<p>If we look carefully:</p>
<ul>
<li>In <code>auth</code>, the contents of <code>flag.txt</code> are <strong>read into a stack buffer</strong> early on.</li>
<li>After reading, <code>auth</code> calls <code>pthread_join</code> to <strong>wait</strong> for <code>userinfo_thread</code> to finish.</li>
<li><strong>Important:</strong> At the time we are writing our name and surname in <code>userinfo</code>, the buffer inside <code>auth</code> is <strong>already populated</strong>.</li>
</ul>
<p>This opens an opportunity:</p>
<ul>
<li>If we can <strong>leak</strong> or <strong>overwrite</strong> the <code>auth</code> thread’s buffer, we can control the value used in the <code>strcmp</code> check.</li>
<li>If we can make the comparison pass, we can <strong>trigger <code>system(&quot;/bin/sh&quot;)</code></strong> and get a shell.</li>
</ul>
<p>Now, recall another crucial observation:</p>
<ul>
<li><strong>The stack regions</strong> for <code>userinfo_thread</code> and <code>auth_thread</code> are <strong>aligned</strong> and <strong>adjacent</strong> (next to each other) in memory.</li>
</ul>
<p>Thus, if we:</p>
<ul>
<li>Allocate a <strong>large enough</strong> name or surname buffer inside <code>userinfo</code> (using <code>alloca</code>),</li>
<li>The allocation can <strong>spill over</strong> into the <code>auth_thread</code>&rsquo;s stack region, especially the part where the <code>flag.txt</code> buffer is stored.</li>
</ul>
<p>Using <code>gdb-pwndbg</code>, I determined that the offset between the base address of the <code>name_buffer</code> (allocated in <code>userinfo_thread</code>) and the <code>auth</code> thread’s <code>buffer</code> is approximately <strong>8,392,928 bytes</strong> — assuming the memory between the two thread stacks is <strong>contiguous</strong>.</p>
<p><img loading="lazy" src='http://localhost:1313/d1ff/images/337cf7a1-cd81-45e3-8133-2ae2815bbed5.png' alt="image.png"></p>
<aside>
💡
<p>Another cool property of <code>strcmp</code>is that it compares two strings <strong>character-by-character until it encounters a null byte (<code>\0</code>)</strong>. In C, strings are null-terminated, so <code>strcmp</code> effectively stops checking as soon as it hits the first null byte.</p>
<p>This means if we manage to overwrite the beginning of the <code>flag</code> buffer with <strong>null bytes</strong> , and simultaneously provide an input consisting of <strong>only null bytes</strong>, <code>strcmp</code> will treat them as matching — allowing us to <strong>bypass the security check</strong>.</p>
</aside>
<hr>
<h2 class="heading-element" id="here-is-the-exploitation-script"><span>Here is the Exploitation Script</span>
  <a href="#here-is-the-exploitation-script" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="ch">#!/usr/bin/env python3</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">elf</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s2">&#34;./terminal_patched&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">libc</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s2">&#34;./libc.so.6&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">ld</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s2">&#34;./ld-linux-x86-64.so.2&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">context</span><span class="o">.</span><span class="n">binary</span> <span class="o">=</span> <span class="n">elf</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">r</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="s1">&#39;20.84.72.194&#39;</span><span class="p">,</span> <span class="s1">&#39;5005&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># r = process()</span>
</span></span><span class="line"><span class="cl"><span class="c1"># gdb.attach(r,gdbscript=&#39;b userinfo&#39;)</span>
</span></span><span class="line"><span class="cl"><span class="n">r</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;First Name Length: &#39;</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="mi">8392928</span><span class="o">-</span><span class="mi">23</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span> <span class="c1">#-23 because the program is adding 23 </span>
</span></span><span class="line"><span class="cl"><span class="n">r</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Surname Length: &#39;</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="mh">0x400</span><span class="o">-</span><span class="mi">23</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">r</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;First Name:&#39;</span><span class="p">,</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x00</span><span class="s1">&#39;</span><span class="o">*</span><span class="mh">0x20</span><span class="o">+</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span> <span class="c1">##### filling the name/flag buffer with null</span>
</span></span><span class="line"><span class="cl"><span class="n">r</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Surname:&#39;</span><span class="p">,</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x00</span><span class="s1">&#39;</span><span class="o">*</span><span class="mh">0x10</span><span class="o">+</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">r</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;Enter security token:&#39;</span><span class="p">,</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\x00</span><span class="s1">&#39;</span><span class="o">*</span><span class="mi">100</span><span class="o">+</span><span class="sa">b</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">r</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span></span></span></code></pre></td></tr></table>
</div>
</div><hr>
<h2 class="heading-element" id="-summary"><span>🐿️ Summary</span>
  <a href="#-summary" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>Here&rsquo;s a quick summary for time-pressed readers</p>
<p>The core idea was about <strong>multithreading</strong>: two threads, <code>userinfo</code> and <code>auth</code>, running side by side.</p>
<ul>
<li><code>userinfo</code> asked for your name and allocated memory on the stack using <code>alloca</code>.</li>
<li><code>auth</code> read the flag into its own stack buffer and waited for <code>userinfo</code> to finish.</li>
</ul>
<p>On remote, the thread stacks were <strong>contiguous</strong> — only a tiny guard page separating them.</p>
<p>Using <code>alloca</code>, we could allocate a massive buffer in <code>userinfo</code> and <strong>overflow into <code>auth</code>&rsquo;s stack</strong>, right where the flag was stored!</p>
<p>we could overwrite the start of the flag buffer with <strong>null bytes</strong>. Since <code>strcmp</code> stops at the first null, it would treat our null-filled input as matching — and <strong>trigger a shell</strong>.</p>
<hr>
<h3 class="heading-element" id="useful-links"><span>Useful links</span>
  <a href="#useful-links" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><p><a href="https://www.scaler.com/topics/multithreading-in-c/"target="_blank" rel="external nofollow noopener noreferrer">https://www.scaler.com/topics/multithreading-in-c/</a></p>
<p><a href="https://www.codequoi.com/en/threads-mutexes-and-concurrent-programming-in-c/"target="_blank" rel="external nofollow noopener noreferrer">https://www.codequoi.com/en/threads-mutexes-and-concurrent-programming-in-c/</a></p>
<hr>
<h3 class="heading-element" id="-connect-with-me"><span>🔗 Connect with me:</span>
  <a href="#-connect-with-me" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ul>
<li><a href="https://github.com/Anony6174"target="_blank" rel="external nofollow noopener noreferrer">GitHub</a></li>
<li><a href="https://X.com/Anuj1337"target="_blank" rel="external nofollow noopener noreferrer">twitter</a></li>
</ul>
<hr></div><div class="post-footer" id="post-footer">
  <div class="post-info">
    <div class="post-info-line">
      <div class="post-info-mod">
        <span title="Updated on 2025-06-20 03:21:46">Updated on 2025-06-20&nbsp;</span>
      </div></div><div class="post-info-line">
        <div class="post-info-md"><span><a href="http://localhost:1313/d1ff/posts/squirrel_writeup/logon/index.md" title="Read Markdown" class="link-to-markdown">Read Markdown</a></span><span><a href="vscode://file/C:%5cUsers%5citisa%5cmy-git%5cd1ff%5ccontent%5cposts%5csquirrel_writeup%5clogon.md" title="Open in editor"target="_blank" rel="external nofollow noopener noreferrer" class="link-to-vscode">Open in editor</a></span></div>
        <div class="post-info-share">
          <span><a href="javascript:void(0);" title="Share on X" data-sharer="twitter" data-url="http://localhost:1313/d1ff/posts/squirrel_writeup/logon/" data-title="Squ1rrelCTF 2025 Writeup (Pwn/Squ1rrel_logon)" data-via="Anuj1337" data-hashtags="Threads,Processes"><i class="fa-brands fa-x-twitter fa-fw" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="Share on Facebook" data-sharer="facebook" data-url="http://localhost:1313/d1ff/posts/squirrel_writeup/logon/" data-hashtag="Threads"><i class="fa-brands fa-facebook-square fa-fw" aria-hidden="true"></i></a>
  <a href="javascript:void(0);" title="Share on 微博" data-sharer="weibo" data-url="http://localhost:1313/d1ff/posts/squirrel_writeup/logon/" data-title="Squ1rrelCTF 2025 Writeup (Pwn/Squ1rrel_logon)"><i class="fa-brands fa-weibo fa-fw" aria-hidden="true"></i></a>
  </span>
        </div>
      </div></div>

  <div class="post-info-more">
    <section class="post-tags"><i class="fa-solid fa-tags fa-fw me-1" aria-hidden="true"></i><a href="http://localhost:1313/d1ff/tags/threads/" class="post-tag" title="Tags - Threads">Threads</a><a href="http://localhost:1313/d1ff/tags/processes/" class="post-tag" title="Tags - Processes">Processes</a></section>
    <section>
      <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="http://localhost:1313/d1ff/">Home</a></span>
    </section>
  </div><div class="post-nav"><a href="http://localhost:1313/d1ff/posts/smiley_writeup/limit/" class="post-nav-item" rel="next" title="SmileyCTF 2025 Writeup (Pwn/Limit)">SmileyCTF 2025 Writeup (Pwn/Limit)<i class="fa-solid fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article>

  <aside class="toc" id="toc-auto" aria-label="Contents"><h2 class="toc-title">Contents&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden="true"></i></h2>
      <div class="toc-content" id="toc-content-auto"></div></aside></main></div><div class="widgets"><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role="button" aria-label="Back to Top"><i class="fa-solid fa-arrow-up fa-fw" aria-hidden="true"></i><span class="variant-numeric d-none">0%</span>
        </div></div><div id="mask"></div><div class="reading-progress-bar" style="left: 0;top: 0;--progress-h: 3px;--bg-progress: #FFA500;--bg-progress-dark: #00FFFF;"></div><noscript>
    <div class="noscript-warning">This website works best with JavaScript enabled.</div>
  </noscript>
</div><link rel="stylesheet" href="http://localhost:1313/d1ff/lib/cookieconsent/cookieconsent.min.css"><script src="http://localhost:1313/d1ff/lib/sharer/sharer.min.js" async defer></script><script src="http://localhost:1313/d1ff/lib/cookieconsent/cookieconsent.min.js" defer></script><script>window.config={"code":{"copyTitle":"Copy to clipboard","editLockTitle":"Lock editable code block","editUnLockTitle":"Unlock editable code block","editable":true,"maxShownLines":10},"comment":{"enable":false},"cookieconsent":{"content":{"dismiss":"Got it!","link":"Learn more","message":"This website uses Cookies to improve your experience."},"enable":true,"palette":{"button":{"background":"#f0f0f0"},"popup":{"background":"#1aa3ff"}},"theme":"edgeless"},"version":"v0.3.21-b2e6f70a"};console.log('Page config:', window.config);</script><script src="http://localhost:1313/d1ff/js/theme.min.js" defer></script></body>
</html>
